//@version=5
// https://TheIceJi.com

indicator(title='TheIceJi Visualize-X', shorttitle='IJN Viz-X', overlay = true , max_labels_count = 500 , max_lines_count = 500 , max_boxes_count = 500 , max_bars_back = 500)
g_MainOpt = 'Main Options'
bool show_zigzag = input(true, 'Zigzag', group=g_MainOpt)
bool show_ribbon = input(true, 'Ribbon', group=g_MainOpt)
bool show_MAactionArea = input(true, 'MA Action area', group=g_MainOpt)
bool show_moreSignal = input(false, 'Additional signals', group=g_MainOpt)
bool show_ewoHistogram = input.bool(true, 'EWO Histogram', inline='VOL', group=g_MainOpt)
bool show_ichiEMA = input.bool(true, 'Ichimuku EMA', group=g_MainOpt)
bool osclLineShowInput = input.bool(true, "Oscillator line", inline = "oscLine", group=g_MainOpt)
bool divLinesShowInput = input.bool(true, "Divergence levels", inline = "divLines", group=g_MainOpt)
bool charDivShowInput = input.bool(true, "Divergence mark", inline = "divChar", group=g_MainOpt)
bool bar_paint = input(true, 'Paint Bar Colors', group=g_MainOpt)
string bar_paintMode = input.string('Change color', 'Bar Paint Mode', options=['Change color', 'Replace candles'], group=g_MainOpt)
string bar_paintType = input.string('CDC', 'Bar Colors Type', options=['CDC', 'DGT', 'OSC', 'MMT', 'Mono', 'none'], group=g_MainOpt)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• //
//# * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//# *
//# * Module : Zigzag
//# *
//# * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• //

// -----------------------------------------------------------------------------------------------
//   Define User Input Variables
// -----------------------------------------------------------------------------------------------
g_Zigzag = 'Zigzag'
atrPeriod = input(10, 'ATR Length', group=g_Zigzag)
factor = input.float(3, 'Factor', step = 0.1, group=g_Zigzag)
atrline = input.float(1.5, 'Premium/Discount', step = 0.1, group=g_Zigzag)
zigzagWidth = input.int(3, 'Width', step = 1, group=g_Zigzag)

// -----------------------------------------------------------------------------------------------
//   Calculations
// -----------------------------------------------------------------------------------------------
[supertrend, direction] = ta.supertrend(factor, atrPeriod)
ATR = ta.atr(atrPeriod)
turnGreen = ta.change(direction) < 0
turnRed   = ta.change(direction) > 0
barsturngreen = bar_index - ta.valuewhen(turnGreen, bar_index, 0)
barsturnred = bar_index - ta.valuewhen(turnRed, bar_index, 0)
barsg = barsturngreen>0 ? barsturngreen : 1
zz_h1 = ta.highest(high,barsg)
barsr = barsturnred>0 ? barsturnred : 1
zz_l2 = ta.lowest(low,barsr) 
barsh = bar_index - ta.valuewhen(ta.change(zz_h1),bar_index,0)
barsl = bar_index - ta.valuewhen(ta.change(zz_l2),bar_index,0)
barsh2 = bar_index - ta.valuewhen(ta.change(zz_h1),bar_index,1)
barsl2 = bar_index - ta.valuewhen(ta.change(zz_l2),bar_index,1)

// -----------------------------------------------------------------------------------------------
//   Drawing
// -----------------------------------------------------------------------------------------------
if turnRed
    if show_zigzag
        line.new(bar_index - barsh, zz_h1, bar_index-barsl2, zz_l2[1], width = zigzagWidth, color=color.lime)
if turnGreen
    if show_zigzag
        line.new(bar_index - barsh2, zz_h1[1], bar_index-barsl, zz_l2, width = zigzagWidth, color = color.fuchsia)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• //
//# * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//# *
//# * Module : Wave Trend
//# *
//# * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• //

// -----------------------------------------------------------------------------------------------
//   Define User Input Variables
// -----------------------------------------------------------------------------------------------
g_WT = 'WaveTrend'
wtChannelLen = input(9, title='WT Channel Length', group=g_WT)
wtAverageLen = input(13, title='WT Average Length', group=g_WT)
wtMASource = input(hlc3, title='WT MA Source', group=g_WT)
wtMALen = input(3, title='WT MA Length', group=g_WT)
obLevel = input(53, title='WT Overbought Level 1', group=g_WT)
obLevel2 = input(60, title='WT Overbought Level 2', group=g_WT)
obLevel3 = input(100, title='WT Overbought Level 3', group=g_WT)
osLevel = input(-53, title='WT Oversold Level 1', group=g_WT)
osLevel2 = input(-60, title='WT Oversold Level 2', group=g_WT)
osLevel3 = input(-80, title='WT Oversold Level 3', group=g_WT)
ema1Len = input(7, title='EMA 1 Length', group=g_WT)
ema2Len = input(14, title='EMA 2 Length', group=g_WT)
ema3Len = input(18, title='EMA 3 Length', group=g_WT)
ema4Len = input(28, title='EMA 4 Length', group=g_WT)
ema5Len = input(34, title='EMA 5 Length', group=g_WT)
ema6Len = input(50, title='EMA 6 Length', group=g_WT)
ema7Len = input(100, title='EMA 7 Length', group=g_WT)
ema8Len = input(200, title='EMA 8 Length', group=g_WT)
rsiSRC = input(close, title='RSI Source', group=g_WT)
rsiLen = input(14, title='RSI Length', group=g_WT)
rsiOversold = input.int(30, title='RSI Oversold', minval=0, maxval=100, group=g_WT)
rsiOverbought = input.int(60, title='RSI Overbought', minval=0, maxval=60, group=g_WT)
rsiMFIperiod = input(60, title='RSI+MFI Period', group=g_WT)
rsiMFIMultiplier = input(150, title='RSI+MFI Area multiplier', group=g_WT)

// -----------------------------------------------------------------------------------------------
//   Functions
// -----------------------------------------------------------------------------------------------
f_wavetrend(_src, _chlen, _avg, _malen) =>
    _esa = ta.ema(_src, _chlen)
    _de = ta.ema(math.abs(_src - _esa), _chlen)
    _ci = (_src - _esa) / (0.015 * _de)
    _tci = ta.ema(_ci, _avg)
    _wt1 = _tci
    _wt2 = ta.sma(_wt1, _malen)
    [_wt1, _wt2]
// 8 EMA Ribbon
f_emaRibbon(_src, _e1, _e2, _e3, _e4, _e5, _e6, _e7, _e8) =>
    _ema1 = ta.ema(_src, _e1)
    _ema2 = ta.ema(_src, _e2)
    _ema3 = ta.ema(_src, _e3)
    _ema4 = ta.ema(_src, _e4)
    _ema5 = ta.ema(_src, _e5)
    _ema6 = ta.ema(_src, _e6)
    _ema7 = ta.ema(_src, _e7)
    _ema8 = ta.ema(_src, _e8)
    [_ema1, _ema2, _ema3, _ema4, _ema5, _ema6, _ema7, _ema8]
f_rsimfi(_period, _multiplier, _tf) =>
    request.security(syminfo.tickerid, _tf, ta.sma((close - open) / (high - low) * _multiplier, _period))

// -----------------------------------------------------------------------------------------------
//   Calculations
// -----------------------------------------------------------------------------------------------
// EMA Ribbon
[ema1, ema2, ema3, ema4, ema5, ema6, ema7, ema8] = f_emaRibbon(close, ema1Len, ema2Len, ema3Len, ema4Len, ema5Len, ema6Len, ema7Len, ema8Len)
// RSI 
rsi = ta.rsi(rsiSRC, rsiLen)
// Calculates WaveTrend
[wt1, wt2] = f_wavetrend(wtMASource, wtChannelLen, wtAverageLen, wtMALen)
// WaveTrend Conditions
wtOverSold = wt2 <= osLevel
wtOverBought = wt2 >= obLevel
wtCross = ta.cross(wt1, wt2)
wtCrossUp = wt2 - wt1 <= 0
wtCrossDown = wt2 - wt1 >= 0
// RSI + MFI
rsiMFI = f_rsimfi(rsiMFIperiod, rsiMFIMultiplier, timeframe.period)
// Signals
longEma = ta.crossover(ema2, ema8)
redCross = ta.crossunder(ema1, ema2)
blueTriangle = ta.crossover(ema2, ema3)
redDiamond = wtCross and wtCrossDown
yellowCross = redDiamond and wt2 < 45 and wt2 > osLevel3 and rsi < 30 and rsi > 15 and rsiMFI < -5
bloodDiamond = redDiamond and redCross
bullCandle = open > ema2 and open > ema8 and close[1] > open[1] and close > open and not redDiamond and not redCross
shortEma = ta.crossover(ema8, ema2)

// -----------------------------------------------------------------------------------------------
//   Drawing
// -----------------------------------------------------------------------------------------------
// EMA Ribbon
ribbonDir = ema8 < ema2
colorEma = ribbonDir ? color.green : color.red
p1 = plot(ema1, color=show_ribbon ? ribbonDir ? color.new(#74abff, 60) : color.new(#ffc774, 60) : na, linewidth=1, title='EMA 1')
p2 = plot(ema2, color=show_ribbon ? ribbonDir ? color.new(#74abff, 60) : color.new(#ffc774, 60) : na, linewidth=1, title='EMA 2')
plot(ema3, color=show_ribbon ? ribbonDir ? color.new(#74abff, 95) : color.new(#ffc774, 95) : na, linewidth=2, title='EMA 3')
plot(ema4, color=show_ribbon ? ribbonDir ? color.new(#74abff, 90) : color.new(#ffc774, 90) : na, linewidth=1, title='EMA 4')
plot(ema5, color=show_ribbon ? ribbonDir ? color.new(#74abff, 85) : color.new(#ffc774, 85) : na, linewidth=1, title='EMA 5')
plot(ema6, color=show_ribbon ? ribbonDir ? color.new(#74abff, 60) : color.new(#ffc774, 60) : na, linewidth=1, title='EMA 6')
plot(ema7, color=show_ribbon ? ribbonDir ? color.new(#74abff, 50) : color.new(#ffc774, 50) : na, linewidth=2, title='EMA 7')
plot(ema8, color=show_ribbon ? ribbonDir ? color.new(#1dce17, 20)  : color.new(#ff3131, 20) : na, linewidth=2, title='EMA 8')
p8 = plot(ema8, color=show_ribbon ? na : colorEma, linewidth=2, title='EMA 8')
fill(p1, p2, color=ribbonDir ? color.new(#1573d4, 85) : color.new(#ffee00, 85))
fill(p2, p8, color=color.new(#363a45, 85))
// SHAPES
plotshape(redCross, style=shape.xcross, color=color.new(#ff0000, 20), location=location.abovebar, title='Red cross')
plotshape(blueTriangle, style=shape.triangleup, color=color.new(#0066ff, 20), location=location.abovebar, title='Blue Triangle')
plotshape(show_moreSignal ? redDiamond : na, style=shape.diamond, color=color.new(#ff0000, 25), location=location.abovebar, title='Red Diamond')
plotshape(show_moreSignal ? bullCandle : na, style=shape.diamond, color=color.new(color.yellow, 75), location=location.abovebar, title='Bull candle')
plotshape(show_moreSignal ? bloodDiamond : na, style=shape.diamond, color=color.new(#ff0000, 15), location=location.abovebar, title='Blood Diamond')
plotshape(show_moreSignal ? yellowCross : na, style=shape.xcross, color=color.new(color.yellow, 25), location=location.abovebar, title='Yellow Cross')

// -----------------------------------------------------------------------------------------------
//   Alerts
// -----------------------------------------------------------------------------------------------
// alertcondition(redDiamond != 0, 'Red Diamond', 'Red Diamond')
// alertcondition(bloodDiamond != 0, 'Blood Diamond', 'Blood Diamond')
// alertcondition(yellowCross != 0, 'YellowX', 'YellowX')
// alertcondition(redCross != 0, 'RedX', 'RedX')
// alertcondition(longEma != 0, 'Longema', 'Longema')
// alertcondition(blueTriangle != 0, 'Bluetriangle', 'Bluetriangle')

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• //
//# * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//# *
//# * Module : ActionZone
//# *
//# * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• //

// -----------------------------------------------------------------------------------------------
//   Define User Input Variables
// -----------------------------------------------------------------------------------------------
g_AZ = 'Action Zone'
xsrc = input(title='Source Data', defval=close, group=g_AZ)
xprd1 = input(title='Fast EMA period', defval=12, group=g_AZ)
xprd2 = input(title='Slow EMA period', defval=26, group=g_AZ)
xsmooth = input(title='Smoothing period (1 = no smoothing)', defval=1, group=g_AZ)
labelSwitch = input(title='Turn on assistive text', defval=false, group=g_AZ)
plotSigsw = input(title='Plot Buy/Sell Signals? ', defval=true, group=g_AZ)
plotRibsw = input(title='Plot Buy/Sell Ribbon', defval=false, group=g_AZ)
plotRibbonPos = input.string(title='Ribbon Position', options=['Top', 'Bottom'], defval='Top', group=g_AZ)
xfixtf = input(title='** Use Fixed time frame Mode (advanced) **', defval=false, group=g_AZ)
xtf = input.timeframe(title='** Fix chart to which time frame ? **)', defval='D', group=g_AZ)
plotSig2sw = input(title='Plot momentum based Buy/Sell Signals? ', defval=false, group=g_AZ)
plotSig2lv = input.int(title='Set signal threshold (higher = stricter)', defval=1, minval=0, maxval=1, group=g_AZ)
// Momentum Signal using StochRSI
smoothK = 3
smoothD = 3
RSIlen = 14
STOlen = 14
SRsrc = close
OSlevel = 30
OBlevel = 70

// -----------------------------------------------------------------------------------------------
//   Calculations
// -----------------------------------------------------------------------------------------------
// Actions
xPrice = ta.ema(xsrc, xsmooth)
FastMA = xfixtf ? ta.ema(request.security(syminfo.tickerid, xtf, ta.ema(xsrc, xprd1), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on), xsmooth) : ta.ema(xPrice, xprd1)
SlowMA = xfixtf ? ta.ema(request.security(syminfo.tickerid, xtf, ta.ema(xsrc, xprd2), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on), xsmooth) : ta.ema(xPrice, xprd2)
Bull = FastMA > SlowMA
Bear = FastMA < SlowMA
// Momentum Signals
rsi1 = ta.rsi(SRsrc, RSIlen)
k = ta.sma(ta.stoch(rsi1, rsi1, rsi1, STOlen), smoothK)
d = ta.sma(k, smoothD)
// Momentum Bar Color
esa = ta.ema(wtMASource, ema1Len)
ci = (wtMASource - esa) / (0.015 * d)
tci = ta.ema(ci, ema2Len)
wt_1 = tci

// -----------------------------------------------------------------------------------------------
//   Define condition
// -----------------------------------------------------------------------------------------------
// Define Color Zones
Green = Bull and xPrice > FastMA  // Buy
Blue = Bear and xPrice > FastMA and xPrice > SlowMA  //Pre Buy 2
LBlue = Bear and xPrice > FastMA and xPrice < SlowMA  //Pre Buy 1
Red = Bear and xPrice < FastMA  // Sell
Orange = Bull and xPrice < FastMA and xPrice < SlowMA  // Pre Sell 2
Yellow = Bull and xPrice < FastMA and xPrice > SlowMA  // Pre Sell 1

// Buy and Sell
buycond = Green and Green[1] == 0
sellcond = Red and Red[1] == 0
bullish = ta.barssince(buycond) < ta.barssince(sellcond)
bearish = ta.barssince(sellcond) < ta.barssince(buycond)
buy = bearish[1] and buycond
sell = bullish[1] and sellcond
bColor_BullBear = bullish ? color.green : bearish ? color.red : color.black

// Momentum Signals
crossover_1 = ta.crossover(k, d)
crossover_2 = ta.crossover(k, d)
iff_1 = d > OSlevel and crossover_2 ? 1 : 0
iff_2 = d < OSlevel and crossover_1 ? 2 : iff_1
storsiBuySig = bullish ? iff_2 : 0

crossunder_1 = ta.crossunder(k, d)
crossunder_2 = ta.crossunder(k, d)
iff_3 = d < OBlevel and crossunder_2 ? 1 : 0
iff_4 = d > OBlevel and crossunder_1 ? 2 : iff_3
storsiSellSig = bearish ? iff_4 : 0

// -----------------------------------------------------------------------------------------------
//   Drawing
// -----------------------------------------------------------------------------------------------
// MA lines
FastL = plot(show_MAactionArea ? FastMA : na, 'Fast EMA', color=color.new(color.red, 0))
SlowL = plot(show_MAactionArea ? SlowMA : na, 'Slow EMA', color=color.new(color.blue, 0))
fillcolor = Bull ? color.new(#00ff4c, 85) : Bear ? color.new(#ff4800, 85) : color.black
fill(FastL, SlowL, fillcolor)
// Buy and Sell point
plotshape(plotSigsw ? buy : na, style=shape.circle, title='Buy Signal', location=location.belowbar, color=color.new(color.green, 0))
plotshape(plotSigsw ? sell : na, style=shape.circle, title='Sell Signal', location=location.abovebar, color=color.new(color.red, 0))
// Buy/Sell Ribbon
plotshape(plotRibsw ? plotRibbonPos == 'Top' ? close : na : na, style=shape.square, title='Buy/Sell Ribbon', location=location.top, color=bColor_BullBear)
plotshape(plotRibsw ? plotRibbonPos == 'Bottom' ? close : na : na, style=shape.square, title='Buy/Sell Ribbon', location=location.bottom, color=bColor_BullBear)
// Momentum Signal using StochRSI
plotshape(plotSig2sw ? storsiBuySig > plotSig2lv ? storsiBuySig : na : na, 'Buy more signals', style=shape.triangleup, location=location.belowbar, color=color.new(color.teal, 0))
plotshape(plotSig2sw ? storsiSellSig > plotSig2lv ? storsiSellSig : na : na, 'Sell more signals', style=shape.triangledown, location=location.abovebar, color=color.new(color.orange, 0))
// Labels
labelstyle = close > SlowMA ? label.style_label_down : label.style_label_up
labelyloc = close > SlowMA ? yloc.abovebar : yloc.belowbar
labeltcolor = buy ? color.black : sell ? color.white : close > close[1] ? color.green : color.red
labelbgcolor = buy ? color.green : sell ? color.red : color.silver
labeltext = buy ? 'BUY next bar\n' : sell ? 'SELL next bar\n' : ' '
trendText = bullish ? 'bullish' : bearish ? 'bearish' : 'sideways'
l1 = label.new(bar_index, na, text=labeltext + syminfo.ticker + ' ' + str.tostring(close) + ' ' + syminfo.currency + '\n currently in a ' + trendText + ' trend \n', color=labelbgcolor, textcolor=labeltcolor, yloc=labelyloc, style=labelstyle)
label.delete(labelSwitch ? l1[1] : l1)

// -----------------------------------------------------------------------------------------------
//   Alerts
// -----------------------------------------------------------------------------------------------
alertcondition(buy, title='*Buy Alert', message='Buy {{exchange}}:{{ticker}}')
alertcondition(sell, title='*Sell Alert', message='Sell {{exchange}}:{{ticker}}')
// alertcondition(bullish, title='is Bullish')
// alertcondition(bearish, title='is Bearish')
// alertcondition(Green, title='is Green')
// alertcondition(Blue, title='is Blue (Strong Rally)')
// alertcondition(LBlue, title='is Light Blue (Rally)')
// alertcondition(Red, title='is Red')
// alertcondition(Orange, title='is Orange (Strong Dip)')
// alertcondition(Yellow, title='is Yellow (Dip)')

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• //
//# * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//# *
//# * Module : Elliott Wave Oscillator Signals 
//# *
//# * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• //


// -----------------------------------------------------------------------------------------------
//   Define User Input Variables
// -----------------------------------------------------------------------------------------------
g_EWO = 'Elliott Wave Oscillator'
ewoSource = input(close, title='EWO Source', group=g_EWO)
ewoEMA = input.bool(true, 'Use Exponential MA', group=g_EWO)
ewoDelay = input.int(5, 'Signal : Delay', minval=2, inline='EWO', group=g_EWO)
ewoThreshold = input.int(13, 'Strength Threshold', minval=1, inline='EWO', group=g_EWO)
ewoPlotLen = input.int(233, 'Plotting Length', group=g_EWO)
ewoOffset = input.int(1000, 'Histogram Offet', group=g_EWO)
oscPlacement = input.string('Bottom', '', options = ['Top', 'Bottom'], inline='VOL'   , group = g_EWO)
oscHight = 21 - input.int(7, 'Hight' , minval = 1, maxval = 10, inline='VOL'  , group = g_EWO) * 2

// -----------------------------------------------------------------------------------------------
//   Calculations
// -----------------------------------------------------------------------------------------------
ewo = ewoEMA ? (ta.ema(ewoSource, 5) / ta.ema(ewoSource, 34) - 1) * 100 : (ta.sma(ewoSource, 5) / ta.sma(ewoSource, 34) - 1) * 100
ewoSignal = ewoEMA ? ta.ema(ewo, ewoDelay) : ta.sma(ewo, ewoDelay)

// -----------------------------------------------------------------------------------------------
//   Drawing
// -----------------------------------------------------------------------------------------------
plotshape(ta.crossover (ewo, ewoSignal) and ewo < -ewoThreshold, 'Strong Long' , shape.labelup  , location.belowbar, color.new(#006400, 40)    , size=size.small, show_last=ewoPlotLen)  //, text="â†‘", textcolor=color.white)
plotshape(ta.crossover (ewo, ewoSignal) and ewo > -ewoThreshold, 'Long'        , shape.labelup  , location.belowbar, color.new(color.green, 70), size=size.tiny , show_last=ewoPlotLen)
plotshape(ta.crossunder(ewo, ewoSignal) and ewo >  ewoThreshold, 'Strong Short', shape.labeldown, location.abovebar, color.new(#910000, 40)    , size=size.small, show_last=ewoPlotLen)  //, text="â†“", textcolor=color.white)
plotshape(ta.crossunder(ewo, ewoSignal) and ewo <  ewoThreshold, 'Short'       , shape.labeldown, location.abovebar, color.new(color.red, 70)  , size=size.tiny , show_last=ewoPlotLen)

// -----------------------------------------------------------------------------------------------
//   EWO Histogram
// -----------------------------------------------------------------------------------------------
lookbackLength  = ewoPlotLen //input.int(200, 'Overlay Indicator Display Length', minval = 10, maxval = 495, group = g) // max lines allowed is 500, where 5 of them to be used for zone definitions 
var a_lines     = array.new_line()
var a_fill      = array.new_linefill()
priceHighest    = ta.highest(high, lookbackLength)
priceLowest     = ta.lowest (low , lookbackLength)
ewoHistograme = ewoEMA ? ta.ema(ewoSource, 5) - ta.ema(ewoSource, 34) : ta.sma(ewoSource, 5) - ta.sma(ewoSource, 34)
ewoHighest      = ta.highest(ewoHistograme, lookbackLength)
ewoColore = ewoHistograme >= 0 ? ewoHistograme[1] < ewoHistograme ? #006400 : color.green : ewoHistograme[1] < ewoHistograme ? color.red : #910000
if barstate.islast and show_ewoHistogram
    if array.size(a_lines) > 0
        for i = 1 to array.size(a_lines)
            line.delete(array.shift(a_lines))

    if array.size(a_fill) > 0
        for i = 1 to array.size(a_fill)
            linefill.delete(array.shift(a_fill))

    priceChangeRate = (priceHighest - priceLowest) / priceHighest / oscHight

    for barIndex = 0 to lookbackLength - 1
        array.push(a_lines, line.new(bar_index[barIndex],  oscPlacement == 'Top' ? priceHighest : priceLowest - ewoOffset, bar_index[barIndex], (oscPlacement == 'Top' ? priceHighest : priceLowest - ewoOffset) * (1 + ewoHistograme[barIndex] / ewoHighest * priceChangeRate), xloc.bar_index, extend.none, ewoColore[barIndex], line.style_solid, 2))

// -----------------------------------------------------------------------------------------------
//   Alerts
// -----------------------------------------------------------------------------------------------

// longAlertCondition = ta.crossover(ewo, ewoSignal)
// alertcondition(longAlertCondition, 'Long : Early Warning', 'EWO-S - Not Confirmed Probable Long Trade Opportunity\n{{exchange}}:{{ticker}}->\nPrice = {{close}},\nTime = {{time}}')
// alertcondition(longAlertCondition[1], 'Long : Trading Opportunity', 'EWO-S - Probable Long Trade Opportunity\n{{exchange}}:{{ticker}}->\nPrice = {{close}},\nTime = {{time}}')
// shortAlertCondition = ta.crossunder(ewo, ewoSignal)
// alertcondition(shortAlertCondition, 'Short : Early Warning', 'EWO-S - Not Confirmed Probable Short Trade Opportunity\n{{exchange}}:{{ticker}}->\nPrice = {{close}},\nTime = {{time}}')
// alertcondition(shortAlertCondition[1], 'Short : Trading Opportunity', 'EWO-S - Probable Short Trade Opportunity\n{{exchange}}:{{ticker}}->\nPrice = {{close}},\nTime = {{time}}')

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• //
//# * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//# *
//# * Module : OWC
//# *
//# * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• //
import TradingView/ta/4 as TvTa
import LucF/ta/2 as LucfTa

string STL1 = "Line"
string STL2 = "Circles"
string STL3 = "Crosses"
// Colors
color LIME      = #00FF00ff
color LIME_MD   = #00FF0090
color LIME_LT   = #00FF0040
color TEAL      = #008080ff
color TEAL_MD   = #00808090
color TEAL_LT   = #00808040
color PINK      = #FF0080ff
color PINK_MD   = #FF008090
color PINK_LT   = #FF008040
color MAROON    = #800000ff
color MAROON_MD = #80000090
color MAROON_LT = #80000040
color ORANGE    = #c56606ff
color ORANGE_BR = #FF8000ff
color GRAY      = #808080ff
color GRAY_MD   = #80808090
color GRAY_LT   = #80808030
color WHITE     = #FFFFFFff
// Oscillators
string OS00 = "None"
string OS01 = "RSI (SL)"
string OS02 = "MACD (S)"
string OS03 = "CCI (SL)"
string OS04 = "Chande Momentum Oscillator (SL)"
string OS05 = "Stochastic (SL)"
string OS06 = "Stochastic RSI (SL)"
string OS09 = "MFI (L)"
string OS10 = "True Strength Index (SL)"
string OS11 = "Williams % Range (L)"
string OS12 = "Ultimate Oscillator (L)"
string OS13 = "Klinger Volume Oscillator (L)"
string OS14 = "Schaff Trend Cycle (SL)"
string OS15 = "Volume Zone Oscillator (L)"
string OS16 = "Price Zone Oscillator (L)"
string OS17 = "Sentiment Zone Oscillator (SL)"
string OS18 = "Wave Period Oscillator (L)"
string OS19 = "Volume Buoyancy (L)"
string OS20 = "Coppock Curve (SL)"
string OS21 = "Aroon (L)"
string OS22 = "DMI (L)"
string OS23 = "TRIX (SL)"
string OS24 = "Ease of Movement (L)"
string OS25 = "Fisher Transform (SL)"
string OS26 = "Signs of the Times"
string OS27 = "Hilbert Transform (S)"
string OS28 = "Intraday Intensity Index"
string OS52 = "True Range"
string OS54 = "Momentum (SL)"
string OS55 = "Rate of Change (SL)"
string OS90 = "Efficient Work (L)"
// Oscillator Channel capping mode
string CAP1 = "Standard deviations"
string CAP2 = "Multiples of ATR"
// Channel level sources
string CH1  = "High and Low"
string CH2  = "Open and Close"
// Channel breach sources
string BR1  = "`low` must breach channel's top, `high` must breach channel's bottom"
string BR2  = "`high` must breach channel's top, `low` must breach channel's bottom"
string BR3  = "Close"
string BR4  = "Open"
string BR5  = "The average of high and low (hl2)"
string BR6  = "The average of high, low and close (hlc3)"
string BR7  = "The average of high, low and two times the close (hlcc4)"
string BR8  = "The average of high, low, close and open (ohlc4)"
// Divergence detection mode
string DIV1 = "Opposite directions of the weighted and reference lines"
string DIV2 = "Opposite directions of the oscillator and the polarity of close to close"
// Bar color choices
string CB0  = "None"
string CB1  = "On divergences only"
string CB2  = "On divergences and on the state of the oscillator channel"
string CB3  = "On divergences and on the state of the divergence channel"
string CB4  = "On divergences and on the combined state of both channels"
// Reference MAs
string MA01 = "Simple MA"
string MA02 = "Exponential MA"
string MA03 = "Wilder MA"
string MA04 = "Weighted MA"
string MA05 = "Volume-weighted MA"
string MA06 = "Arnaud Legoux MA"
string MA07 = "Hull MA"
string MA08 = "Symmetrically-weighted MA"


// -----------------------------------------------------------------------------------------------
//   Define User Input Variables
// -----------------------------------------------------------------------------------------------
string  GRP1 = "Oscillators and relative volume"
string  osc1TypeInput           = input.string(OS01,        "Oscillator 1",                         group = GRP1, inline = "osc1", options = [OS00, OS21, OS03, OS04, OS20, OS22, OS24, OS90, OS25, OS27, OS28, OS13, OS02, OS09, OS54, OS16, OS55, OS01, OS14, OS17, OS26, OS05, OS06, OS23, OS52, OS10, OS12, OS19, OS15, OS18, OS11])
string  osc1SourceInput         = input.string("close",     "",                                     group = GRP1, inline = "osc1", options = ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4", "hlcc4", "volume"])
int     osc1LengthInput         = input.int(20,             "Length",                              group = GRP1, inline = "osc1", minval = 2)
string  osc2TypeInput           = input.string(OS00,        "Oscillator 2",                         group = GRP1, inline = "osc2", options = [OS00, OS21, OS03, OS04, OS20, OS22, OS24, OS90, OS25, OS27, OS28, OS13, OS02, OS09, OS54, OS16, OS55, OS01, OS14, OS17, OS26, OS05, OS06, OS23, OS52, OS10, OS12, OS19, OS15, OS18, OS11])
string  osc2SourceInput         = input.string("close",     "",                                     group = GRP1, inline = "osc2", options = ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4", "hlcc4", "volume"])
int     osc2LengthInput         = input.int(20,             "Length",                              group = GRP1, inline = "osc2", minval = 2)
bool    oscXInput               = input.bool(false,         "Oscillator 3 (external)",              group = GRP1, inline = "oscX")
float   oscXSourceInput         = input.source(close,       "",                                     group = GRP1, inline = "oscX")
float   oscXCenterInput         = input.int(0,              "Center",                               group = GRP1, inline = "oscX")
bool    useRelVolWeightInput    = input.bool(false,         "Use weight of relative volume over n bars", group = GRP1, inline = "RelVolW")
int     relVolLookbackInput     = input.int(100,            "",                                     group = GRP1, inline = "RelVolW", minval = 2)

string  GRP2 = "Oscillator channel"
color   refLineUpColorInput     = input.color(TEAL,         "ğŸ¡‘",                                   group = GRP2, inline = "refLineColors")
color   refLineDnColorInput     = input.color(MAROON,       "ğŸ¡“",                                    group = GRP2, inline = "refLineColors")
string  refTypeInput            = input.string(MA06,        "",                                   group = GRP2, inline = "ref", options = [MA01, MA02, MA03, MA04, MA05, MA06, MA07, MA08])
string  refSourceInput          = input.string("close",     "",                                     group = GRP2, inline = "ref", options = ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4", "hlcc4", "volume"])
int     refLengthInput          = input.int(20,             "Length",                              group = GRP2, inline = "ref", minval = 2)

int     oscLineWidthInput       = input.int(2,              "Weighted Width",                            group = GRP2, inline = "oscLine", minval = 1)
string  oscLineStyleInput       = input.string(STL1,        "",                                     group = GRP2, inline = "oscLine", options = [STL1, STL2, STL3])
color   oscLineUpUpColorInput   = input.color(LIME,         "ğŸ¡‘ğŸ¡‘",                                 group = GRP2, inline = "oscLineColors") 
color   oscLineDnDnColorInput   = input.color(PINK,         "ğŸ¡“ğŸ¡“",                                   group = GRP2, inline = "oscLineColors") 
color   oscLineUpColorInput     = input.color(TEAL,         "ğŸ¡‘",                                   group = GRP2, inline = "oscLineColors") 
color   oscLineDnColorInput     = input.color(MAROON,       "ğŸ¡“",                                    group = GRP2, inline = "oscLineColors") 
float   oscChannelCapInput      = input.float(3.0,          "Cap the channel's height to",        group = GRP2, inline = "cap", minval = 1, step = 0.5)
string  oscChannelCapModeInput  = input.string(CAP1,        "",                                     group = GRP2, inline = "cap", options = [CAP1, CAP2])

string  GRP3 = "Divergence channel"
int     divLinesWidthInput      = input.int(1,              "Divergence Width",                      group = GRP3, inline = "divLines", minval = 1)
string  divLinesStyleInput      = input.string(STL1,        "",                                     group = GRP3, inline = "divLines", options = [STL1, STL2, STL3])
color   divLinesUpUpColorInput  = input.color(LIME,         "ğŸ¡‘ğŸ¡‘",                                 group = GRP3, inline = "divLinesColors")
color   divLinesDnDnColorInput  = input.color(PINK,         "ğŸ¡“ğŸ¡“",                                   group = GRP3, inline = "divLinesColors")
color   divLinesUpColorInput    = input.color(TEAL,         "ğŸ¡‘",                                   group = GRP3, inline = "divLinesColors")
color   divLinesDnColorInput    = input.color(MAROON,       "ğŸ¡“",                                    group = GRP3, inline = "divLinesColors")
color   divLinesNtColorInput    = input.color(GRAY,         "N",                                    group = GRP3, inline = "divLinesColors")

string  divChannelLevelsInput   = input.string(CH1,         "Levels are defined using",           group = GRP3, options = [CH1, CH2])
string  divChannelBreachesInput = input.string(BR1,         "Breaches are determined using",      group = GRP3, options = [BR1, BR2, BR3, BR4, BR5, BR6, BR7, BR8])
string  divDetectionModeInput   = input.string(DIV1,        "Detect divergences on",              group = GRP3, inline = "divDetection", options = [DIV1, DIV2])
bool    divChannelBiasInput     = input.string("Off",       "Estimate unbreached channel bias",   group = GRP3, options = ["On", "Off"]) == "On"
string  charDivInput            = input.string("â€¢",         "Divergence mark",                      group = GRP3, inline = "divChar")
color   charDivColorInput       = input.color(ORANGE,       "",                                     group = GRP3, inline = "divChar")
bool    charDivAboveInput       = input.bool(true,          "Above bar",                            group = GRP3, inline = "divChar")

string  GRP4 = "OSC Bar Color"
string  colorBarModeInput       = input.string(CB2,         "",                                     group = GRP4, inline = "barMode", options = [CB1, CB2, CB3, CB4])
bool    barsEmptyOnDecVolInput  = input.bool(false,         "Don't color falling volume bars",      group = GRP4, inline = "barMode")
color   barsUpUpColorInput      = input.color(LIME,         "ğŸ¡‘ğŸ¡‘",                                 group = GRP4, inline = "barColors")
color   barsDnDnColorInput      = input.color(PINK,         "ğŸ¡“ğŸ¡“",                                   group = GRP4, inline = "barColors")
color   barsUpColorInput        = input.color(TEAL,         "ğŸ¡‘",                                    group = GRP4, inline = "barColors")
color   barsDnColorInput        = input.color(MAROON,       "ğŸ¡“",                                    group = GRP4, inline = "barColors")
color   barsNtColorInput        = input.color(GRAY,         "N",                                    group = GRP4, inline = "barColors")
color   barsDivColorInput       = input.color(ORANGE,       "D",                                    group = GRP4, inline = "barColors")

// -----------------------------------------------------------------------------------------------
//   Functions
// -----------------------------------------------------------------------------------------------
lineStyleFromUserInput(userSelection) =>
    result = switch userSelection
        STL1 => plot.style_line
        STL2 => plot.style_circles
        STL3 => plot.style_cross
        => plot.style_line
checkForNoVolume(simple string type) =>
    bool oscUsesVolume = type == OS09 or type == OS15 or type == OS19 or type == OS24
    if barstate.islast and ta.cum(nz(volume)) == 0 and oscUsesVolume
        runtime.error("No volume is provided by the data vendor.")
oscCenter(simple string type) =>
    float result = 
      switch type
        OS01 => 50.
        OS05 => 50.
        OS06 => 50.
        OS09 => 50.
        OS11 => -50.
        OS12 => 50.
        OS14 => 50.
        => 0.
oscCalc(simple string type, series float src, simple int length) =>
    float result = 
      switch type
        OS00 => na
        OS01 => ta.rsi(src, length)
        OS02 => 
            [_, _, histLine] = ta.macd(src, 12, 26, 9)
            histLine
        OS03 => ta.cci(src, length)
        OS04 => ta.cmo(src, length)
        OS05 => ta.stoch(src, high, low, length)
        OS06 => 
            float rsi = ta.rsi(src, length)
            ta.sma(ta.stoch(rsi, rsi, rsi, length), 3)
        OS09 => ta.mfi(hlc3, length)
        OS10 => ta.tsi(src, length, length * 2)
        OS11 => ta.wpr(length)
        OS12 => TvTa.uo(length / 2, length, length * 2)
        OS13 => 
            [kvo, _] = TvTa.kvo(length, length * 2, length / 2)
            kvo
        OS14 => TvTa.stc(src, length, length * 2, length / 2, 3, 3)
        OS15 => TvTa.vzo(length)
        OS16 => TvTa.pzo(length)
        OS17 => TvTa.szo(src, length)
        OS18 => TvTa.wpo(length)
        OS19 => LucfTa.buoyancy(volume, length, 1000)
        OS20 => TvTa.coppock(src, length, length / 2, length / 2)
        OS21 => 
            [up, dn] = TvTa.aroon(length)
            up - dn
        OS22 => 
            [up, dn, _] = ta.dmi(length, length)
            up - dn
        OS23 => 
            [trix, signal, hist] = TvTa.trix(src, length, int(length * 0.66))
            trix
        OS24 => TvTa.eom(length)
        OS25 => TvTa.ft(src, length)
        OS26 => LucfTa.sott()
        OS27 => TvTa.ht(src)
        OS28 => ta.iii
        OS52 => ta.tr * math.sign(ta.change(close))
        OS54 => ta.mom(src, length)
        OS55 => ta.roc(src, length)
        OS90 => LucfTa.efficientWork(length)
        => na
oscWeight(series float osc, simple float center = 0.0) =>
    float normalizedOsc = osc - center
    float historicalMax = math.abs(ta.max(normalizedOsc))
    float historicalMin = math.abs(ta.min(normalizedOsc))
    float result =
      switch 
        osc > center => normalizedOsc / historicalMax
        osc < center => - math.abs(normalizedOsc / historicalMin)
        => 0.

// -----------------------------------------------------------------------------------------------
//   Calculations
// -----------------------------------------------------------------------------------------------
checkForNoVolume(osc1TypeInput)
checkForNoVolume(osc2TypeInput)
var float osc1Center = oscCenter(osc1TypeInput)
var float osc2Center = oscCenter(osc2TypeInput)
var float oscXCenter = oscXCenterInput
float osc1 = oscCalc(osc1TypeInput, LucfTa.sourceStrToFloat(osc1SourceInput), osc1LengthInput)
float osc2 = oscCalc(osc2TypeInput, LucfTa.sourceStrToFloat(osc2SourceInput), osc2LengthInput)
float oscX = oscXInput ? oscXSourceInput : na
int qtyOfOscillators = (not na(osc1) ? 1 : 0) + (not na(osc2) ? 1 : 0) + (not na(oscX) ? 1 : 0)
float weight1 = oscWeight(osc1, osc1Center)
float weight2 = oscWeight(osc2, osc2Center)
float weightX = oscWeight(oscX, oscXCenter)
float weight = (weight1 + weight2 + weightX) / qtyOfOscillators
float relVolPctRank   = ta.percentrank(volume, relVolLookbackInput) / 100.
float relVolumeWeight = useRelVolWeightInput and not na(volume) ? relVolPctRank : 1.
float combinedWeight  = weight * relVolumeWeight
float refSource      = LucfTa.sourceStrToFloat(refSourceInput)
float capUnits       = oscChannelCapModeInput == CAP1 ? ta.stdev(refSource, refLengthInput) : ta.atr(20)
float weightedSource = refSource + (math.sign(combinedWeight) * math.min(refSource * math.abs(combinedWeight), capUnits * oscChannelCapInput))
float reference      = LucfTa.ma(refTypeInput, refSource, refLengthInput)
float weightedRef    = LucfTa.ma(refTypeInput, weightedSource, refLengthInput)
bool oscChannelBull = weightedRef > reference
bool oscChannelBear = not oscChannelBull
bool oscChannelBullStrong = oscChannelBull and close > reference and ta.rising(reference, 1)  and ta.rising(weightedRef, 1)
bool oscChannelBearStrong = oscChannelBear and close < reference and ta.falling(reference, 1) and ta.falling(weightedRef, 1)

bool divergence = divDetectionModeInput == DIV1 ? math.sign(ta.change(reference)) != math.sign(ta.change(weightedRef)) : math.sign(ta.change(combinedWeight)) != math.sign(ta.change(close))
float divChannelHiSrc = divChannelLevelsInput == CH1 ? high : math.max(open, close)
float divChannelLoSrc = divChannelLevelsInput == CH1 ? low  : math.min(open, close)
float divBreachHiSrc  = na
float divBreachLoSrc  = na
switch divChannelBreachesInput
    BR1 =>
        divBreachHiSrc := low
        divBreachLoSrc := high
    BR2 =>
        divBreachHiSrc := high
        divBreachLoSrc := low
    BR3 =>
        divBreachHiSrc := close
        divBreachLoSrc := close
    BR4 =>
        divBreachHiSrc := open
        divBreachLoSrc := open
    BR5 =>
        divBreachHiSrc := hl2
        divBreachLoSrc := hl2
    BR6 =>
        divBreachHiSrc := hlc3
        divBreachLoSrc := hlc3
    BR7 =>
        divBreachHiSrc := hlcc4
        divBreachLoSrc := hlcc4
    BR8 =>
        divBreachHiSrc := ohlc4
        divBreachLoSrc := ohlc4

[divChannelHi, divChannelLo, divChannelBull, divChannelBear, divChannelBreached, newDivChannel, preBreachUpChanges, preBreachDnChanges] = LucfTa.divergenceChannel(divergence, divChannelHiSrc, divChannelLoSrc, divBreachHiSrc, divBreachLoSrc)
color refLineColor = na
color oscLineColor  = na
color oscChannelColor  = na
switch
    oscChannelBullStrong =>
        oscLineColor    := oscLineUpUpColorInput
    oscChannelBearStrong =>
        oscLineColor    := oscLineDnDnColorInput
    oscChannelBull =>
        oscLineColor    := oscLineUpColorInput
    oscChannelBear =>
        oscLineColor    := oscLineDnColorInput
bool divChannelBullStrong = divChannelBull and oscChannelBullStrong
bool divChannelBearStrong = divChannelBear and oscChannelBearStrong



// -----------------------------------------------------------------------------------------------
//   Define condition
// -----------------------------------------------------------------------------------------------
bool preBreachBiasBull = not divChannelBreached and divChannelBiasInput and preBreachUpChanges > preBreachDnChanges
bool preBreachBiasBear = not divChannelBreached and divChannelBiasInput and preBreachUpChanges < preBreachDnChanges
color divLinesColor = na
if divChannelBreached
    switch
        divChannelBullStrong =>
            divLinesColor := divLinesUpUpColorInput
        divChannelBearStrong =>
            divLinesColor := divLinesDnDnColorInput
        divChannelBull =>
            divLinesColor := divLinesUpColorInput
        divChannelBear =>
            divLinesColor := divLinesDnColorInput
        =>
            divLinesColor := divLinesNtColorInput
else
    switch
        divChannelBiasInput and preBreachBiasBull =>
            divLinesColor := divLinesUpColorInput
        divChannelBiasInput and preBreachBiasBear =>
            divLinesColor := divLinesDnColorInput
        =>
            divLinesColor := divLinesNtColorInput

// -----------------------------------------------------------------------------------------------
//   Drawing
// -----------------------------------------------------------------------------------------------
// Plot the channel levels and fill.
var bool plotDivLineValues = divLinesShowInput
var divLineStyle = lineStyleFromUserInput(divLinesStyleInput)
float divChannelMid = math.avg(divChannelHi, divChannelLo)
divChannelHiPlot  = plot(plotDivLineValues ? divChannelHi  : na, "Divergence Channel Hi", not newDivChannel and divLinesShowInput ? divLinesColor : na, divLinesWidthInput, divLineStyle)
divChannelLoPlot  = plot(plotDivLineValues ? divChannelLo  : na, "Divergence Channel Lo", not newDivChannel and divLinesShowInput ? divLinesColor : na, divLinesWidthInput, divLineStyle)
// Plot Divergence channel.
divChannelMidPlot = plot(plotDivLineValues ? divChannelMid : na, "Divergence Channel Mid", na, display = display.none)
// Plot OSC Line
var oscLineStyle = lineStyleFromUserInput(oscLineStyleInput)
weightedPlot = plot(osclLineShowInput ? weightedRef : na, "Weighted Reference",  osclLineShowInput  ? oscLineColor  : na, oscLineWidthInput, oscLineStyle)
// Plot Divergence Mask
plotchar(charDivShowInput ? divergence : na, "Divergence character", charDivInput, charDivAboveInput ? location.abovebar : location.belowbar, charDivColorInput, size = size.tiny)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• //
//# * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//# *
//# * Module : Global Transformations
//# *
//# * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• //

// Display color on chart
bColor_CDC = Green ? color.green : Blue ? color.blue : LBlue ? color.aqua : Red ? color.red : Orange ? color.orange : Yellow ? color.yellow : color.black
bColor_mono = Green or Blue or LBlue ? #b2b5be : Yellow ? #858891 : #5d606b
bColor_MMT = color.from_gradient(wt_1, -60, 60, #2962ff, #ff9800)

color bColor_OSC = if bar_paint
    switch colorBarModeInput
        CB1 =>
            switch
                divergence           => barsDivColorInput
        CB2 =>
            switch
                divergence           => barsDivColorInput
                oscChannelBullStrong => barsUpUpColorInput
                oscChannelBearStrong => barsDnDnColorInput
                oscChannelBull       => barsUpColorInput
                oscChannelBear       => barsDnColorInput
                => barsNtColorInput
        CB3 =>
            switch
                divergence           => barsDivColorInput
                divChannelBullStrong => barsUpUpColorInput
                divChannelBearStrong => barsDnDnColorInput
                divChannelBull       => barsUpColorInput
                divChannelBear       => barsDnColorInput
                => barsNtColorInput
        CB4 =>
            switch
                divergence => barsDivColorInput
                oscChannelBullStrong and divChannelBullStrong => barsUpUpColorInput
                oscChannelBearStrong and divChannelBearStrong => barsDnDnColorInput
                (oscChannelBull or oscChannelBullStrong) and (divChannelBull or divChannelBullStrong) => barsUpColorInput
                (oscChannelBear or oscChannelBearStrong) and (divChannelBear or divChannelBearStrong) => barsDnColorInput
                => barsNtColorInput
        => na
else
    na

bColor = bar_paintType == 'CDC' ? bColor_CDC : bar_paintType == 'DGT' ? na : bar_paintType == 'OSC' ? bColor_OSC : bar_paintType == 'MMT' ? bColor_MMT : bar_paintType == 'Mono' ? bColor_mono : color.new(#ffffff, 100)

var bar_replaceCandles = bar_paintMode == 'Replace candles' and bar_paint
barcolor(color=bar_paint ? bColor : na)
plotcandle(open, high, low, close, color = bar_replaceCandles ? bColor : na, wickcolor = bar_replaceCandles ? bColor : na, bordercolor = bar_replaceCandles ? bColor : na, editable = false)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• //
//# * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//# *
//# * Module : Ichimuku EMA
//# *
//# * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• //

g_ichiEma = 'Ichimuku EMA'
len = input.int(26, minval=1, group=g_ichiEma)
conversionPeriods = input.int(5, minval=1, group=g_ichiEma)
basePeriods = input.int(26, minval=1, group=g_ichiEma)
laggingSpan2Periods = input.int(52, minval=1, group=g_ichiEma)
displacement = input.int(26, minval=1, group=g_ichiEma)
ichiColorBG = input.color(color.new(color.silver, 90), 'Ichimuku Color', group=g_ichiEma)

donchian(len) => math.avg(ta.lowest(len), ta.highest(len))

conversionLine = donchian(conversionPeriods)
baseLine = donchian(basePeriods)
leadLine1 = show_ichiEMA ? math.avg(conversionLine, baseLine) : na
leadLine2 = show_ichiEMA ? donchian(laggingSpan2Periods) : na

ichi_p1 = plot(leadLine1, offset = displacement, color=color.new(color.green, 85))
ichi_p2 = plot(leadLine2, offset = displacement, color=color.new(color.red, 85))
fill(ichi_p1, ichi_p2, color=ichiColorBG)